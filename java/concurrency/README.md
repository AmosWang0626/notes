---
title: Java 高效并发
date: 2020-05-16
categories: Java
---

# Java 高效并发
> 学习是一个发散的过程，层层递进，连贯起来，如故事一样。

## 目录
1. 并发有什么用？
2. Java 内存模型（JMM）
    - 回顾计算机内存模型
    - 主内存与工作内存
    - 原子性、可见性与有序性
    - 先行发生原则（happens-before）
3. 亲儿子解决方案
    - 大娃 Synchronized
    - 二蛋 Volatile
4. 并发基础 CAS 与 AQS
    - ReentrantLock
    - 其他并发集合
5. 线程池
6. 总结

---
# 一、并发有什么用？

并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。——引自《深入理解Java虚拟机》

**摩尔定律：**摩尔定律是指IC上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。由英特尔名誉董事长戈登·摩尔1965年提出。**但是，时间是无穷的，IC上可容纳的晶体管数目也是有极限的。**

**Amdahl 定律：**在一个系统中，并行化和串行化的比重，描述了多处理器系统能获得的运算加速能力。**对于串行化的任务，计算机处理器再多也无用；对于可并行的任务，处理器越多，自然是越快的。**

并发充分利用CPU资源，降低系统响应时间，提升系统吞吐量。

---
# 二、Java 内存模型（JMM）
> Java Memory Model，JMM。用它来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。

## 2.1 回顾计算机内存模型

内存与处理器速度的矛盾，是引入高速缓存的重要原因。

高速缓存工作原理：将运算需要使用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

每个处理器都有自己的高速缓存，而它们又共享同一个主内存，当同时操作同一块主内存区域时，以谁的数据为准呢？缓存一致性问题闪亮登场。

缓存一致性问题解决方案：

- 总线加锁。早期CPU多为此方案，一个线程处理，其他线程阻塞，问题就是效率低下；
- 缓存一致性协议。处理器访问缓存时需遵循对应协议，最出名的就是 Intel 的 MESI 了。

![计算机内存模型](https://gitee.com/AmosWang/resource/raw/master/image/jvm/computer-memory-model.png)

- 此处的主内存，对应物理机的 RAM 运行内存，就是常说的8GB、16GB内存；

  - RAM（Random Access Memory）随机存储内存，对应电脑的运行内存，断电会丢失存储的内容；
  - ROM（Read Only Memory）只读内存，对应电脑的硬盘存储。

- 当然，和高速缓存直接通信的是处理器中的寄存器；高速缓存也常分为一级缓存、二级缓存和三级缓存。

- [MESI](https://zh.wikipedia.org/wiki/MESI协议) 多核 CPU 多级缓存一致性协议，共享数据通过 cache line 标记。

  | 状态 | 描述 |
  | :----- | :--- |
  | M 修改 Modified | 缓存行是脏的（*dirty*），与主存的值不同。如果别的 CPU内核要读主存这块数据，该缓存行必须写回（*flush*）主存，变为共享状态(S)。 |
  | E 独享 Exclusive | 缓存行只在当前缓存中，并且是干净的（*clean*），与主存的值相同。当别的缓存读取它时，变为共享状态(S)；当前写数据时，变为修改状态(M)。 |
  | S 共享 Shared    | 缓存行也存在于其它缓存中，并且是干净的。缓存行可以在任意时刻抛弃。 |
  | I 无效 Invalid   | 缓存行是无效的。                         |

## 2.2 主内存与工作内存

通俗地说，工作内存就是线程私有的内存，主内存就是线程共享的内存。

工作方式：

- 线程修改工作内存的数据，因为是线程私有的，直接修改即可；
- 线程修改主内存的数据，线程不能直接修改主内存数据，需要先将主内存数据 Load 到工作内存，修改完，将数据 Save 到主内存，此时就涉及脏读和并发写的问题了。如何保证呢？也就是下文的内容了——加锁。

![Java内存模型](https://gitee.com/AmosWang/resource/raw/master/image/jvm/java-memory-model.png)

对照下图，是不是很熟悉？线程隔离数据区、线程共享数据区。

![Java 运行时数据区](https://gitee.com/AmosWang/resource/raw/master/image/jvm/jvm-runtime-data-area.png)

## 2.3 原子性、可见性与有序性

- **原子性**（*不可分割*）

  - 基本数据类型的访问、读写都是具备原子性的。

    由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。

    **注意：**多个原子操作放一起，就不能保证原子性了，例如 i++ 就不是原子操作。

  - synchronized 块之间的操作具备原子性。

    如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，也即 synchronized 的底层实现。

- **可见性**（*当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改*）

  Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。

  - volatile 实现可见性

    volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。

  - synchronized 实现可见性
    对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）

  - final 实现可见性

    被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。

- **有序性**（*线程内表现为串行的语义 As-If-Serial*）

  程序代码的执行顺序可能和我们写的代码顺序不一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。

  - volatile 实现有序性

    volatile 包含了禁止指令重排序的语义。相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。

  - synchronized 实现有序性

    一个变量在同一个时刻只允许一条线程对其进行lock操作，持有同一个锁的两个同步块只能串行地进入。

## 2.4 先行发生原则（happens-before）

Java 天生支持先行发生原则，具体原则如下。如果两个操作之间的关系不在此列，并且无法从下列规则推导出
来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

- 程序次序规则（在一个线程内，按照程序代码顺序，书写在前的先行于书写在后的。准确讲，是控制流顺序）
- 管程锁定规则（一个 unlock 操作先行于后边对同一个锁的 lock 操作。后边指时间上的先后顺序）
- volatile 变量规则（对一个变量的写操作先行于后边读操作。后边同样指时间上的先后顺序）
- 线程启动规则（Thread.start() 先行于此线程的每一个动作）
- 线程终止规则（线程中的所有操作都先行于对此线程的终止监测）
- 线程中断规则（Thread.interrupt() 方法的调用先行于中断代码的监测）
- 对象终结规则（一个对象的初始化完成先行于它的 finalize()）
- 传递性（A先行发生于B，B先行发生于C，则可得出操作A先行发生于C的结论）

---
# 三、亲儿子解决方案


## 3.1 大娃 Synchronized
> JDK 1.6 之前为重量级锁；之后为偏向锁，如果竞争激烈，会自动升级。（偏向锁 > 轻量级锁 > 重量级锁）

1. 加锁方式

   - 同步方法
     1. 静态方法
     2. 非静态方法
   - 同步代码块
     1. 对象锁
     2. 类锁（本质上也是对象锁，ClassLoader 加载的类，都有一个 Class 对象）

2. 解决问题

   原子性：同一时间，只允许一个线程持有某个对象锁，保证原子性。

   可见性：锁释放之前，对共享变量的修改，对于随后获取该锁的线程是可见的。

   有序性：持有同一个锁的两个同步块只能串行地进入，保证了有序性。

3. 实现原理

   这两个都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。

   - 同步方法

     方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。

     虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。

   - 同步代码块

     Java虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 Javac 编译器与 Java虚拟机两者共同协作支持。

     ```java
     void onlyMe(Foo f) {
       synchronized(f) {
     	  doSomething();
       }
     }
     ```


     ```c
     Method void onlyMe(Foo)
     0 aload_1		// 将对象f入栈
     1 dup			// 复制栈顶元素（即f的引用）
     2 astore_2		// 将栈顶元素存储到局部变量表变量槽 2中
     3 monitorenter	// 以栈定元素（即f）作为锁，开始同步
     4 aload_0		// 将局部变量槽 0（即this指针）的元素入栈
     5 invokevirtual #5	// 调用doSomething()方法
     8 aload_2 		// 将局部变量Slow 2的元素（即f）入栈
     9 monitorexit 	// 退出同步
     10 goto 18 		// 方法正常结束，跳转到18返回
     13 astore_3 	// 从这步开始是异常路径，见下面异常表的Taget 13
     14 aload_2 		// 将局部变量Slow 2的元素（即f）入栈
     15 monitorexit 	// 退出同步
     16 aload_3 		// 将局部变量Slow 3的元素（即异常对象）入栈
     17 athrow 		// 把异常对象重新抛出给onlyMe()方法的调用者
     18 return 		// 方法正常返回
     Exception table:
     FromTo Target Type
     4 10 13 any
     13 16 13 any
     ```

     编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须有其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。

## 3.2 二蛋 Volatile

> 轻量级锁

1. 加锁方式

   定义在变量上

2. 解决问题

   可见性：新值能立即同步到主内存，以及每次使用前立即从主内存刷新。

   有序性：禁止指令重排序，重排序时不能把后面的指令重排序到内存屏障之前的位置。

3. 实现原理

   

---
# 四、并发基础 CAS 与 AQS

## 4.1 ReentrantLock

> 针对的问题，jdk1.6之前，只要加上 synchronized，不管有没有并发，都会加上重量级锁，导致性能低下。
>
> Doug Lea 大神开发了JUC包，给出了加锁第二方案。


## 4.2 其他并发集合

---
# 五、线程池

---
# 六、总结

## 梳理关键词

- JUC（java.util.concurrent）Java 并发包
- 偏向锁、轻量级锁、重量级锁、锁消除、锁升级、公平锁、非公平锁