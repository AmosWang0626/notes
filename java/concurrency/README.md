---
title: Java 高效并发
date: 2020-05-16
categories: Java
---

# Java 高效并发
> 学习是一个发散的过程，层层递进，连贯起来，如故事一样。

## 目录
1. 并发有什么用？
2. Java 内存模型（JMM）
    - 计算机内存模型
    - 主内存与工作内存
    - 原子性、可见性与有序性
    - 先行发生原则（happens-before）
3. 亲儿子解决方案
    - 大娃 Synchronized
    - 二蛋 Volatile
4. 并发基础 CAS 与 AQS
    - ReentrantLock
    - 其他并发集合
5. 线程池
6. 总结

---
# 一、并发有什么用？

并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。——引自《深入理解Java虚拟机》

**摩尔定律：**摩尔定律是指IC上可容纳的晶体管数目，约每隔18个月便会增加一倍，性能也将提升一倍。由英特尔名誉董事长戈登·摩尔1965年提出。**但是，时间是无穷的，IC上可容纳的晶体管数目也是有极限的。**

**Amdahl 定律：**在一个系统中，并行化和串行化的比重，描述了多处理器系统能获得的运算加速能力。**对于串行化的任务，计算机处理器再多也无用**，又如女性十月怀胎；**对于可并行的任务，处理器越多，自然是越快的**，又如很多人收庄稼。

并发充分利用CPU资源，降低系统响应时间，提升系统吞吐量。

---
# 二、Java 内存模型（JMM）
> Java Memory Model，JMM

## 2.1 计算机内存模型

内存与处理器速度的矛盾，是引入高速缓存的重要原因，但是引入了一个新的问题：缓存一致性。

高速缓存工作原理：将运算需要使用到的数据复制到缓存中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

缓存一致性问题：每个处理器都有自己的高速缓存，而它们又共享同一个主内存，当同时操作同一块主内存区域时，以谁的数据为准呢？为此有一系列协议，处理器访问缓存时需遵循对应协议，常见的协议有MSI、MESI、MOSI等等。

![计算机内存模型](https://gitee.com/AmosWang/resource/raw/master/image/jvm/computer-memory-model.png)

备注：

- 此处的主内存，对应物理机的 RAM 运行内存，就是常见的8GB、16GB内存；

- RAM（Random Access Memory）随机存储内存，对应电脑的运行内存，断电会丢失存储的内容；

- ROM（Read Only Memory）只读内存，对应电脑的物理存储；

- MESI 多核 CPU 多级缓存一致性协议，共享数据通过 cache line 标记，如果失效，需要从主内存重新加载。

  | 状态 | 描述 | 监听任务 |
  | :----- | :--- | :--- |
  | M 修改 Modified | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 |
  | E 互斥 Exclusive | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。  |
  | S 共享 Shared    | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 |
  | I 无效 Invalid   | 该Cache line无效。                                         | 无 |

## 2.2 主内存与工作内存

![Java内存模型](https://gitee.com/AmosWang/resource/raw/master/image/jvm/java-memory-model.png)

![Java 运行时数据区](https://gitee.com/AmosWang/resource/raw/master/image/jvm/jvm-runtime-data-area.png)


## 2.3 原子性、可见性与有序性


## 2.4 先行发生原则（happens-before）

---
# 三、亲儿子解决方案


## 3.1 大娃 Synchronized
> JDK 1.6 之前为重量级锁；之后为偏向锁，如果竞争激烈，会自动升级。（偏向锁 > 轻量级锁 > 重量级锁）

## 3.2 二蛋 Volatile
> 轻量级锁

---
# 四、并发基础 CAS 与 AQS

## 4.1 ReentrantLock

> 针对的问题，jdk1.6之前，只要加上 synchronized，不管有没有并发，都会加上重量级锁，导致性能低下。
>
> Doug Lea 大神开发了JUC包，给出了加锁第二方案。


## 4.2 其他并发集合

---
# 五、线程池

---
# 六、总结

## 梳理关键词

- JUC（java.util.concurrent）Java 并发包
- 偏向锁、轻量级锁、重量级锁、锁消除、锁升级、公平锁、非公平锁